<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="jsut 4 fun" />



  <meta name="keywords" content="Hexo,next" />



  <link rel="alternate" href="/atom.xml" title="Go7hic" type="application/atom+xml" />



  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="###一：隐式类型转换
**（0）：提要**

JavaScript 是非常宽容的，「来者不拒」，不在乎什么类型。 例如，它如果想要接受数字，它并不拒绝其他类型的值，而是试图把它们转换成数字：

&amp;gt; &apos;5&apos; - &apos;2&apos;
3
&amp;gt; &apos;5&apos; * &apos;2&apos;
10

自动转换为布尔值通常不会引起问题，而且往往很有用（译注：比如在C语言里，根本就没有布尔类型。by @justjavac）。 即使如此，这些隐式转">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript的12个怪癖">
<meta property="og:url" content="http://blog.yongyuan.us/2014/07/17/2014-07-17-js-12-guaipi/index.html">
<meta property="og:site_name" content="Go7hic">
<meta property="og:description" content="###一：隐式类型转换
**（0）：提要**

JavaScript 是非常宽容的，「来者不拒」，不在乎什么类型。 例如，它如果想要接受数字，它并不拒绝其他类型的值，而是试图把它们转换成数字：

&amp;gt; &apos;5&apos; - &apos;2&apos;
3
&amp;gt; &apos;5&apos; * &apos;2&apos;
10

自动转换为布尔值通常不会引起问题，而且往往很有用（译注：比如在C语言里，根本就没有布尔类型。by @justjavac）。 即使如此，这些隐式转">
<meta property="og:updated_time" content="2015-07-24T16:08:38.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript的12个怪癖">
<meta name="twitter:description" content="###一：隐式类型转换
**（0）：提要**

JavaScript 是非常宽容的，「来者不拒」，不在乎什么类型。 例如，它如果想要接受数字，它并不拒绝其他类型的值，而是试图把它们转换成数字：

&amp;gt; &apos;5&apos; - &apos;2&apos;
3
&amp;gt; &apos;5&apos; * &apos;2&apos;
10

自动转换为布尔值通常不会引起问题，而且往往很有用（译注：比如在C语言里，根本就没有布尔类型。by @justjavac）。 即使如此，这些隐式转">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'post'
  };
</script>

  <title> JavaScript的12个怪癖 | Go7hic </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">Go7hic</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-next-about"></i> <br />
            关于
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              JavaScript的12个怪癖
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2014-07-17T00:00:00+08:00" content="2014-07-17">
            2014-07-17
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody">
###一：隐式类型转换
**（0）：提要**

JavaScript 是非常宽容的，「来者不拒」，不在乎什么类型。 例如，它如果想要接受数字，它并不拒绝其他类型的值，而是试图把它们转换成数字：

> '5' - '2'
3
> '5' * '2'
10

自动转换为布尔值通常不会引起问题，而且往往很有用（译注：比如在C语言里，根本就没有布尔类型。by @justjavac）。 即使如此，这些隐式转换也会引起怪癖（quirks）。 但是当自动转换为字符串时，可能会引起问题。
<a id="more"></a>
**(1)：隐式转换为布尔：“truthy”和“falsy”**

当 JavaScript 需要一个布尔值时（例如：if 语句），任何值都可以被使用。 最终这些值将被转换为 true 或 false。

下面的值被转换为 false：

undefined, null
Boolean: false
Number: -0, +0, NaN
String: ''

所有其他值都认为是 true。 被转换成 'false' 的值我们成之为 falsy，被转换成 'true' 的值我们成之为 truthy。 您可以使用 Boolean 来测试一个值到底被转换成了什么。

Boolean 将其参数转换为布尔值（boolean）：

> Boolean(undefined)
false
> Boolean(0)
false
> Boolean(3)
true

**(2)、字符串的隐式转换**

在 Web 开发中，我们经常得到字符串值，实际上我们期望的却是数字或者布尔值。 例如，用户输入的表单中的数据。 如果你忘了对这些字符串进行显式的转换，那么 JavaScript 会令你感到惊讶，主要体现在两个方面：

首先，系统不会有任何警告。
其次，这些值将被自动转换，但确实错误的。
例如，加运算符（+），就有这方面的问题，因为只要其中一个操作数是字符串，那么它就执行连接字符串的操作（而不是加法操作，即使它们是数字）。

在下面的 JavaScript 代码中，我们本来预期是把 1 和 5 相加。 但是，我们使用了字符串 '5' 和 '1' 。

> var x = '5';  // 错误的假设：x 是一个数字

> x + 1
'51'
此外，还有一些看似是 false 的值，如果转换成字符串，却成了 'true'。

例如：false。

> Boolean(false)
false
> String(false)
'false'
> Boolean('false')  // ！！
true
例如： undefined.

> Boolean(undefined)
false
> String(undefined)
'undefined'
> Boolean('undefined')  // ！！
true

**(3)、对象的隐式转换**

只有在 JavaScript 表达式或语句中需要用到数字或字符串时，对象才被隐式转换。 当需要将对象转换成数字时，需要以下三个步骤：

调用 valueOf()。如果结果是原始值（不是一个对象），则将其转换为一个数字。
否则，调用 toString() 方法。如果结果是原始值，则将其转换为一个数字。
否则，抛出一个类型错误。
第一步示例:

> 3 * { valueOf: function () { return 5 } }
15
第三步示例:

> function returnObject() { return {} }
> 3 * { valueOf: returnObject, toString: returnObject }
TypeError: Cannot convert object to primitive value

如果把对象转换成字符串时，则转换操作的第一步和第二步的顺序会调换： 先尝试 toString() 进行转换，如果不是原始值，则再尝试使用 valueOf()。

###二：两个「空值」：undefined 和 null
对于“空值”或“空引用”，大多数编程语言只有一个值。比如，在 Java 中用的是 null。 但是在 Javascript 中却有两个特殊的值: undefined 和 null。 他们基本上是相同，但用法上却略有些不同。 在这个 系列教程 的最后，我会解释一下在 ECMAScript 6 中的一些变化。

undefined 是被语言本身所分配的。 如果一个变量还没有被初始化，那么它的值就是 undefined:

> var foo;
> foo
undefined

同理，当缺失参数时 JavaScript 会分配一个 undefined：

> function id(x) { return x }
> id()
undefined

`null` 是被开发者用来明确指出某个值是缺失的， 例如，对于 JSON.stringify():

> console.log(JSON.stringify({ first: 'Jane' }, null, 4))
{
    "first": "Jane"
}

校检：一个变量是否有值？

如果你想知道变量 v 是否有值，正常情况下，你需要同时检验 undefined 与 null。 幸运的是两个值都是 false 型。 因此，只用一个判断，就可以同时检验这两项是否为真:

<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">if</span> (v) &#123;</span><br><span class="line">    <span class="comment">// v 有值</span></span><br><span class="line">&#125; <span class="tag">else</span> &#123;</span><br><span class="line">    <span class="comment">// v 没有值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

在本 系列 的第 5 部分——关于函数参数的处理——你将会看到更多的上面校检例子。 有一点要注意的是：这个检查也会把 false, -0, +0, NaN 与 '' 当成“空值”。 如果这不是你想要的，那么就不能使用上面的校检方法了。

你有两个选择。

有些人提倡使用不等于（!=）来校检 v 既不是 undefined 或 null:

<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (v != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// v 有值</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// v 没有值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

不过，这要求你要明白 `!= `认为 `null` 只等于它自己或是` undefined`。 我喜欢用更有可读性的` !==`:

<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (v !== <span class="literal">undefined</span> &amp;&amp; v !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// v 有值</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// v 没有值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

性能方面，所有在这个章节中提到的这三个校检基本是相同的。 所以，最后用哪个取决于你的需求还有你的品味。 一些压缩工具甚至用 != 重写了最后一条校检。

### 三：标准的等号 (==)

让我们先看一个简单的例子： 由于一般的等于符号 `==`、`!=`经常会出现问题，以至于我们不得不使用严格等于(===、!==)。 当然有人说这些规则也有例外，我不同意这个观点2。 怀揣的这个问题，我们现在就来看一下这个奇怪的现象：== 是不必要。

这个“正常”的等号（==）有很多怪癖。 虽然他很宽容（非严格比较），当与真值或者假值比较时，它会忽略类型（详见怪癖1）：

> 0 == false  // OK
true
> 1 == true  // OK
true
> 2 == true  // not OK
false

> '' == false  // OK
true
> '1' == true  // OK
true
> '2' == true  // not OK
false


除了这些，我们设置可以把那些明显不能比较的值进行比较（我勒个去～～比较的结果居然还是 true）：


> '' == 0
true
> '\n  123  \t' == 123
true


最后一次比较返回是 true，因为在 javascript 中把字符串转换数字类型时，会过滤掉首尾空白字符。 如果你仍然对关于 == 怎么工作感兴趣，你可以读读这篇文章。 对于严格比较符（===），不同类型的值比较是不相等的 1。也就是说试用严格比较符号，上诉的问题都不复存在。

###四：未知变量名创建全局变量

此文是 javascript 的 12 个怪癖（quirks） 系列的第四篇。

当你使用了一个未知的变量名，通常 JavaScript 会自动创建全局变量：

`function f() { foo = 123 } f() foo 123`


好在你会在 ECMAScript5 的严谨模式得到警告[1]：


`function f() { 'use strict'; foo = 123 } f() ReferenceError: foo is not defined`

###五：参数的处理

1、参数处理的基本原理

JavaScript 的参数处理包括两个要点


1.1、要点：你可以传递任意数量的参数

当调用一个 function 时，你想传递多少参数都可以，这与该函数声明了多少个正式的参数无关。 缺失参数的值是 undefined，多出来的参数则直接被忽略掉。

我们用以下的函数做个示范：

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x: '</span>+x);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'y: '</span>+y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

你可以用任意数量的参数调用这个 function：

> f()
x: undefined
y: undefined

> f('a')
x: a
y: undefined

> f('a', 'b')
x: a
y: b

> f('a', 'b', 'c')
x: a
y: b


1.2要点：所有传递的参数都储存在 arguments 中

所有传递的参数都储存在一个很特别、很像 Array（继续看就能知道为什么了）的变量里，arguments。 通过下面的 function 我们来看下这个变量怎么用的：

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Length: '</span>+<span class="built_in">arguments</span>.length);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Elements: '</span>+fromArray(<span class="built_in">arguments</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

下面是 fromArray 函数，它把 arguments 转换成 array 这样就能存入数据了，调用 g()：

> g()
Length: 0
Elements:
> g('a')
Length: 1
Elements: a
> g('a', 'b')
Length: 2
Elements: a,b


无论明确声明了多少个参数，arguments 是永远在那里的，它总是包含所有实际的参数。

**2、参数传递了吗？**

如果调用者没有提供参数，那么 undefined 就会传递给 function。 因为 undefined 是一个虚拟值[1]，你可以用一个 if 条件语句来检验它是否存在：

<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasParameter</span><span class="params">(param)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (param) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'yes'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'no'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

这样，你不传参数与传入 undefined 获得的结果是一样的：

'no'
> hasParameter(undefined)
'no'


测试代码对真实值(truthy)同样有效：

> hasParameter([ 'a', 'b' ])
'yes'
> hasParameter({ name: 'Jane' })
'yes'
> hasParameter('Hello')
'yes'

而对于虚拟值(falsy)的会用是需要多加小心的。 比如 false、0 以及空字符串都被解析为缺失参数：


> hasParameter(false)
'no'
> hasParameter(0)
'no'
> hasParameter('')
'no'


这段代码足以证明。 你必须要多加注意，因为代码变得更加紧凑与调用者是否忽略了一个参数还是传递了 undefined 或者 null 都无关。

**3、参数的默认值**

以下的 function 可以传入 0 或者其他参数，x 和 y 如果未传参数则会是 0，以下是一种表现方式：

<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(x, y)</span> &#123;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="params">(!x)</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> <span class="params">(!y)</span> y = <span class="number">0</span>;</span><br><span class="line">    return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

交互后：

> add()
0
> add(5)
5
> add(2, 7)
9

你可以用 or 运算符（||）使 add() 更简洁。 如果为真这个运算符会返回第一个值否则返回第二个。

例如：

> 'abc' || 'def'
'abc'
> '' || 'def'
'def'
> undefined || { foo: 123 }
{ foo: 123 }
> { foo: 123 } || 'def'
{ foo: 123 }

我们用 || 来指定参数默认值：

<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">    x = x || <span class="number">0</span>;</span><br><span class="line">    y = y || <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**4、任意数量的参数**

你也可以用 arguments 来接收任意数量的参数，其中一个例子是以下的函数 format()，它在 C 函数 sprintf 之后输出语句：

> format('Hello %s! You have %s new message(s).', 'Jane', 5)
'Hello Jane! You have 5 new message(s).


第一个参数是一个样式，由 %s 标记空白，后面的参数则填入这些标记，简单的 format 函数实现如下：

<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span><span class="params">(pattern)</span> &#123;</span></span><br><span class="line">    <span class="keyword">for</span>(var <span class="built_in">i</span>=<span class="number">1</span>; <span class="built_in">i</span> &lt; arguments.<span class="built_in">length</span>; <span class="built_in">i</span>++) <span class="cell">&#123;</span><br><span class="line">        pattern = pattern.replace(<span class="string">'%s'</span>, arguments[i]);</span><br><span class="line">    &#125;</span></span><br><span class="line">    <span class="keyword">return</span> pattern;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

注意：循环跳过了第一个参数(arguments[0]) 并且忽略了 pattern。

**5、强制执行一定数量的参数**

如果你想要强制调用者执行一定数量的参数，你就要在运行阶段检查 arguments.length：

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &gt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Need at most 2 parameters'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**6、arguments 不是 array**

arguments 并不是 array，它只是很像 array，你可以获取第 i 个参数比如 arguments[i]， 你也可以检查它有多少个参数比如 arguments.length。 但是你不能用 Array 的方法如 forEach 或者 indexOf。 更多详情与解答会在「怪癖8（未翻译）」中进行讨论，作为一个预习，以下函数能将一个类似 array 的值转换为 array：

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fromArray</span>(<span class="params">arrayLikeValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(arrayLikeValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

**7、参考**

[1] JavaScript quirk 1: implicit conversion of values [解释了“真实值(truthy)”与“虚拟值(falsy)”]

###六：变量的作用范围 

此文是 javascript 的 12 个怪癖（quirks） 系列的第六篇。

在大多数编程语言中，变量的生命周期是“定义此变量的块（block）”。 但是在 JavaScript 中，变量的作用域却和函数息息相关，而不是大括号：

<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">(x)</span> &#123;</span></span><br><span class="line">    console.<span class="built_in">log</span><span class="params">(tmp)</span>; <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">if</span> <span class="params">(x &lt; <span class="number">0</span>)</span> &#123;</span><br><span class="line">        var tmp = <span class="number">100</span> - x;  <span class="comment">// (*)</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

（译注：很多程序员会觉得 tmp 变量的作用于是 if 块，其实不然，javascript 根本没有块作用域。）

上述代码引发的行为是：函数内部，在（*）处声明的变量 tmp 被移动到了函数的开头（赋值语句依然保留在原处）。 也就是说，实际上此段代码在 JavaScript 引擎中的运行时，看起来像这样：

<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">(x)</span> &#123;</span></span><br><span class="line">    var tmp;</span><br><span class="line">    console.<span class="built_in">log</span><span class="params">(tmp)</span>; <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">if</span> <span class="params">(x &lt; <span class="number">0</span>)</span> &#123;</span><br><span class="line">        tmp = <span class="number">100</span> - x;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

但是，有一招可以把一个变量限制在一个块作用域，它被称为立即函数表达式（IIFE，发音为“iffy”）。

立即函数表达式：`Immediately Invoked Function Expression。`

下面，我们使用一个 IIFE，将 tmp 的作用域限制在包含它的 if 语句块中。

<figure class="highlight"><figcaption><span>func(x) &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    console.log(tmp); // ReferenceError: tmp is not defined&#10;    if (x &#60; 0) &#123;&#10;        (function () &#123;  // open IIFE&#10;            var tmp = 100 - x;&#10;            ...&#10;        &#125;());  // close IIFE&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>

我们在内部块的外面，写了一个函数，创建了一个新的作用域。 （译注：javascript 没有块作用域，OMG！。只有函数作用域，因此我们必须使用一个匿名函数，而且是立即执行的匿名函数创建了一个新的作用域。） 然后我们立即执行此函数。 tmp 仅仅存在于 IIFE 中。 需要注意的是围绕此 IIFE 的小括号是必须的。

如果没有环绕 IIFE 的小括号，函数成了：

<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="number">100</span> - x;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

执行结果：

<figure class="highlight"><figcaption><span>Unexpected token (```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;&#65288;why&#65311;&#65289;&#10;&#10;&#10;&#20316;&#32773;&#20889;&#36947;&#65292;&#10;&#10;&#62; They lead to the function being interpreted as an expression, which is&#10;&#62; the only form in which it can be be immediately invoked.&#10;&#10;&#25105;&#20204;&#38656;&#35201;&#22312; IIFE &#30340;&#24320;&#22987;&#21644;&#32467;&#26463;&#30340;&#22320;&#26041;&#65292;&#20889;&#19978;&#23567;&#25324;&#21495;&#65292;&#25226;&#20989;&#25968;&#35299;&#26512;&#25104;&#19968;&#20010;&#34920;&#36798;&#24335;&#12290; &#36825;&#26159;&#25226;&#20989;&#25968;&#21464;&#25104;&#31435;&#21363;&#35843;&#29992;&#30340;&#21807;&#19968;&#24418;&#24335;&#12290;&#10;&#21040;&#24213;&#26159;&#19981;&#26159;&#21807;&#19968;&#24418;&#24335;&#21602;&#65311;&#10;&#10;&#10;      1. (function () &#123;&#10;            var tmp = 100 - x; &#10;      &#125;());&#10;  &#10;  &#10;      2. (function () &#123;&#10;            var tmp = 100 - x; &#10;      &#125;)(); &#10;      &#10;&#65288;and why&#65311;&#65289;&#10;&#10;&#10;&#30041;&#19979;&#20102;&#20960;&#20010;&#30097;&#38382;&#65292;&#21407;&#20316;&#32773;&#27809;&#26377;&#20889;&#26126;&#65292;&#30001;&#20110;&#31687;&#24133;&#20851;&#31995;&#65292;&#25105;&#20250;&#22312;&#38543;&#21518;&#30340;&#21338;&#25991;&#20013;&#35299;&#37322;&#12290;&#10;&#10;&#19981;&#36807;&#20851;&#20110;&#34920;&#36798;&#24335;&#30340;&#30097;&#38382;&#21487;&#20197;&#21435;&#30475;&#25105;&#20889;&#30340;&#12302;&#20195;&#30721;&#20043;&#35868;&#12303;&#31995;&#21015;&#20043;&#35821;&#21477;&#19982;&#34920;&#36798;&#24335;&#12290; &#26368;&#21518;&#19968;&#20010;&#30097;&#38382;&#21487;&#20197;&#35835;&#19968;&#19979; &#21629;&#21517;&#20989;&#25968;&#34920;&#36798;&#24335;&#25506;&#31192;&#10;&#10;###&#19971;:&#21464;&#37327;&#38381;&#21253;&#20043;&#21518;&#30340;&#26080;&#24847;&#35782;&#20849;&#20139; &#10;&#27492;&#25991;&#26159; javascript &#30340; 12 &#20010;&#24618;&#30294;&#65288;quirks&#65289; &#31995;&#21015;&#30340;&#31532;&#19971;&#31687;&#12290;&#10;&#10;&#38381;&#21253;&#26159; JavaScript &#19968;&#20010;&#24378;&#22823;&#30340;&#29305;&#24615;&#65306;&#24403;&#20989;&#25968;&#31163;&#24320;&#20102;&#21019;&#24314;&#23427;&#30340;&#20301;&#32622;&#65292;&#20173;&#28982;&#21487;&#20197;&#33719;&#21462;&#21040;&#35813;&#20301;&#32622;&#19978;&#23384;&#22312;&#30340;&#25152;&#26377;&#21464;&#37327;&#12290; &#26412;&#25991;&#20027;&#35201;&#35299;&#37322;&#38381;&#21253;&#30340;&#24037;&#20316;&#26041;&#24335;&#20197;&#21450;&#25105;&#20204;&#20026;&#20160;&#20040;&#35201;&#23545;&#20110;&#21464;&#37327;&#30340;&#26080;&#24847;&#35782;&#20849;&#20139;&#22810;&#21152;&#23567;&#24515;&#12290;&#10;&#10;**1&#12289;&#38381;&#21253;**&#10;&#10;&#25105;&#20204;&#20174;&#19968;&#20010;&#38381;&#21253;&#30340;&#20363;&#23376;&#24320;&#22987;&#21543;&#65306;</span><br></pre></td></tr></table></figure>

function incrementorFactory(start, step) {
    return function () {  // (*)
        start += step;
        return start;
    }
}
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">下面调用 incrementorFactory：</span><br><span class="line"></span><br><span class="line">&gt; var inc = incrementorFactory(<span class="number">20</span>, <span class="number">2</span>);</span><br><span class="line">&gt; inc()</span><br><span class="line"><span class="number">22</span></span><br><span class="line">&gt; inc()</span><br><span class="line"><span class="number">24</span></span><br><span class="line"></span><br><span class="line">在运行阶段，内部函数(*)能获取到外部函数 incrementorFactory 的变量 <span class="literal">start</span> 与 step，而且 incrementorFactory 不只返回函数， 也连带返回了变量 <span class="literal">start</span> 与 step。 存储这两个变量的数据结构叫做 <span class="literal">environment</span>，<span class="literal">environment</span> 与 object 非常相似——它将键名映射到键值。 以上返回的函数包含了 <span class="literal">environment</span> 的引用，它在父级即外部的 <span class="literal">environment</span> 时就已经激活。 组合函数 + <span class="literal">environment</span> 就叫做闭包。 这名称来源于当 <span class="literal">environment</span> “关闭”函数时：它为变量提供了可声明在函数外的值（这就是所谓的自由变量）。</span><br><span class="line"></span><br><span class="line">当函数被请求，就会为它的参数和局部变量创建一个新的 <span class="literal">environment</span>。 所以总会有一连串的<span class="literal">environment</span>：</span><br><span class="line"></span><br><span class="line">f 的 <span class="literal">environment</span></span><br><span class="line">f 的外部 <span class="literal">environment</span></span><br><span class="line">f 外的 <span class="literal">environment</span> 外部的 <span class="literal">environment</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">全局变量的 <span class="literal">environment</span>（全局 <span class="literal">environment</span>）</span><br><span class="line">以上是从 f 的 <span class="literal">environment</span>开始，完全搜索 <span class="literal">environment</span> 链查看的所有变量值。</span><br><span class="line"></span><br><span class="line">**<span class="number">2</span>、怪癖：无意识共享**</span><br><span class="line"></span><br><span class="line">闭包并不是在特定的时间点获得快照，它是获取动态的变量，以下是这个问题的例子：</span><br></pre></td></tr></table></figure>

var result = [];
for (var i=0; i < 5; i++) {
    result.push(function () { return i });  // (*)
}
console.log(result[3]()); // 5 (not 3)
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当函数在这里(*)创建的时候，变量 i 有一个确定的值，你可能会觉得那个函数返回的会一直是那个值。 相反，它与动态的i是一直关联着的，就是说所有 <span class="literal">result</span> 数组中的函数都是通过它们的外部 environment 关联同一个 i，当循环结束时，i 的值就是 <span class="number">5</span>。</span><br><span class="line"></span><br><span class="line">一种可行的解决方案就是通过一个返回值(<span class="type">Immediately</span> <span class="type">Invoked</span> <span class="type">Function</span> <span class="type">Expression</span>)<span class="number">1</span>来复制 i 的当前值：</span><br></pre></td></tr></table></figure>

for (var i=0; i < 5; i++) {
   (function (i2) {  // snaphot of i
       result.push(function () { return i2 });
   }(i));
}
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">你也可以用 <span class="function"><span class="title">bind</span><span class="params">()</span></span> 函数，也有相似的效果：</span><br></pre></td></tr></table></figure>

for (var i=0; i < 5; i++) {
    result.push(function (i2) { return i2 }.bind(null, i));
}
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">用 forEach 和 Underscore<span class="class">.js</span> 库中的 <span class="function"><span class="title">range</span><span class="params">()</span></span> 函数也可以办到：</span><br></pre></td></tr></table></figure>

_.range(5).forEach(function (i) {
    result.push(function () { return i });
});
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以上的代码都可行，因为每次请求参数时，forEach 都创建了一个新的i变量。</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span>2.1 一个实际应用的例子<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"></span><br><span class="line">下面我们用一个更加实用的例子来总结下。 两天前，我做了一 个Connect Four 游戏的 UI 来作为 DOM 的示例，它包含了以下的代码片段， 添加了事件侦听来连接到游戏板的行列上。</span><br></pre></td></tr></table></figure>

for(var col=0; col < board4.DIM_X; col++) {
    document.getElementById('columnClick'+col)
            .addEventListener('click', function (col) {
                currentState.columnClick(col);
                event.preventDefault();
            }.bind(null, col));
}
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">另一种方式是用 CSS 类来代替 ID，重写以上代码：</span><br></pre></td></tr></table></figure>

Array.prototype.forEach.call(
  document.getElementsByClassName('columnClick'),
  function (elem, col) {  // (*)
      elem.addEventListener('click', function () {
          currentState.columnClick(col);
          event.preventDefault();
      });
  });
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">这样，函数(<span class="keyword">*</span>)的每次调用都会创建一个新的变量 col，而且不会有无意识共享发现。</span><br><span class="line"></span><br><span class="line">本系列的最后一篇文章会讲解用 ECMAScript6 来处理无意识共享的问题。</span><br><span class="line"></span><br><span class="line">3、引用</span><br><span class="line"></span><br><span class="line">[1] JavaScript quirk 6: the scope of variables</span><br><span class="line"></span><br><span class="line"><span class="comment">###八：“类数组对象”  </span></span><br><span class="line"></span><br><span class="line">JavaScript中有一些看起来像却又不是数组的对象，唤作类数组。 本文旨在探究类数组的确切含义和高效的使用方式。</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span>类数组<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"></span><br><span class="line">一个类数组对象：</span><br><span class="line"></span><br><span class="line">具有：指向对象元素的数字索引下标以及 length 属性告诉我们对象的元素个数</span><br><span class="line">不具有：诸如 push 、 forEach 以及 indexOf 等数组对象具有的方法</span><br><span class="line">两个典型的类数组的例子是：DOM方法 document.getElementsByClassName() 的返回结果（实际上许多DOM方法的返回值都是类数组）以及特殊变量 arguments [1]。</span><br><span class="line">例如你可以通过以下方法确定函数参数的个数</span><br><span class="line"></span><br><span class="line">`arguments.length`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">你也可以获取单个参数值，例如读取第一个参数：</span><br><span class="line"></span><br><span class="line">`arguments[0]`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果这些对象想使用数组的方法，就必须要用某种方式“借用”。由于大部分的数组方法都是通用的，因此我们可以这样做。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span>通用方法<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"></span><br><span class="line">所谓的通用方法就是不强制要求函数的调用对象 this 必须为数组，仅需要其拥有 length 属性和数字索引下标即可。 通常来讲，你可以用如下的方式在数组 arr 上调用方法 m ：</span><br><span class="line"></span><br><span class="line">```arr.m(arg0, arg1, ...)</span><br></pre></td></tr></table></figure>

所有的函数都拥有一个 call 方法来让我们用这样一种方式进行上述调用：

`Array.prototype.m.call(arr, arg0, arg1, ...)`

call 方法的第一个参数就是函数 m 的调用对象 this 的值（在这个例子里就是 arr）。 因为我们直接调用方法 m ，而非通过数组对象 arr ，因此我们可以为本方法更改任意的 this 值。

例如改为 arguments :

`Array.prototype.m.call(arguments, arg0, arg1, ...)`

例子

让我们来看一个具体的例子。 下面的 printArgs 列出了函数的全部参数值。

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printArgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.prototype.forEach.call(<span class="built_in">arguments</span>,</span><br><span class="line">        <span class="function"><span class="keyword">function</span> (<span class="params">arg, i</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(i+<span class="string">'. '</span>+arg);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

我们“通用地”使用了方法 forEach。 printArgs 的运行结果如下：

    > printArgs()
    > printArgs('a')
    0. a
    > printArgs('a', 'b')
    0. a
    1. b
    

你甚至可以应用通用方法给普通的对象：

    > var obj = {};
    > Array.prototype.push.call(obj, 'a');
    1
    > obj
    { '0': 'a', length: 1 }
    
在上述例子中，length 属性原本不存在并以0为初始值自动创建。

将类数组对象转化为数组

有时候处理类数组对象的最好方法是将其转化为数组。 这项工作也可以使用通用方法来完成：

`Array.prototype.slice.call(arguments)`

对于正常复制数组对象而言，我们额外使用了 call 的方法。

`arr.slice() `

未完待续:
转自https://github.com/justjavac/12-javascript-quirks


</span>
      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2014/07/20/2014-07-20-scope/" rel="prev">JavaScript启示录(一)笔记： 作用域和闭包</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2014/07/14/2014-07-14-javascript_strict_mode/" rel="next">Javascript 严格模式详解</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
          </div>
        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/tx.jpg" alt="Go7hic" itemprop="image"/>
          <p class="site-author-name" itemprop="name">Go7hic</p>
        </div>
        <p class="site-description motion-element" itemprop="description">jsut 4 fun</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">86</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            
              <span class="site-state-item-count">0</span>
              <span class="site-state-item-name">分类</span>
              
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="menu-item-icon icon-next-feed"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <p class="post-toc-empty">此文章未包含目录</p>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2015</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Go7hic</span>
</div>

<div class="">
  「万物之中，希望至美；至美之物，永不凋零」
</div>

 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.1" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
